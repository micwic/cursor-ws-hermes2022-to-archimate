---
description: Gouvernance du logging Javascript (console.log, console.error, tra√ßabilit√©)
alwaysApply: true
---

# logging-governance.mdc : Gouvernance du logging Javascript

> Cr√©√© le : 2025-11-01
> Derni√®re mise √† jour : 2025-11-01

## Objectifs de la r√®gle

- Harmoniser le logging Javascript dans les fonctions
- Assurer la tra√ßabilit√© des ex√©cutions (entr√©e de fonction)
- Fournir des messages de log clairs et contextualis√©s
- Faciliter le d√©bogage et la maintenance
- √âviter les refactorings de tests excessifs lors de la maintenance corrective et √©volutive

## Probl√®mes r√©solus/√† r√©soudre

- Absence de journalisation en entr√©e de fonction ‚Üí difficult√© de tra√ßabilit√©
- Messages de log g√©n√©riques sans contexte fonctionnel ‚Üí difficult√© d'identification de la source
- Incoh√©rence dans l'utilisation de `console.log()` vs `console.error()`
- Tests de logging trop stricts n√©cessitant des refactorings fr√©quents lors de la maintenance

## Comportement g√©n√©ral attendu

- L'IA et l'utilisateur appliquent syst√©matiquement les patterns d√©finis ci-dessous
- Les messages de log sont contextualis√©s et permettent d'identifier rapidement la fonction source
- Les tests de logging utilisent une validation flexible (presence et fragments plut√¥t que contenu exact)

## Contexte d'application et g√©n√©ralit√©s

- S'applique √† tout le code JavaScript/TypeScript
- Utilise `console.log()` pour information et tra√ßabilit√©
- Utilise `console.error()` pour erreurs avant propagation
- Compatible avec Node.js 16+ et les frameworks de test (Jest, Jest-Cucumber)

## R√®gles √† appliquer

### Pattern 1 : Journalisation en entr√©e de fonction

#### Description

Utiliser pour tracer l'entr√©e des fonctions d'orchestration afin de faciliter le d√©bogage et la tra√ßabilit√© des ex√©cutions.

#### Pattern valid√©

```javascript
async function loadInstructions(config) {
  // Journalisation en entr√©e de fonction pour tra√ßabilit√© (bonne pratique reconnue)
  console.log(`[info] Chargement des instructions depuis config.nuextract.templateTransformationInstructions.instructions`);
  
  try {
    // ... logique m√©tier ...
    return instructions;
  } catch (error) {
    console.error(`Erreur lors du chargement des instructions: ${error.message}`);
    throw error;
  }
}
```

#### R√®gles

- **Pr√©fixe `[info]`** : Utiliser `[info]` pour identifier les messages d'information (facilite le filtrage dans les logs)
- **Message contextualis√©** : Identifier clairement la fonction et l'action effectu√©e
- **Position** : En d√©but de fonction, avant toute logique m√©tier
- **Formatage** : Utiliser template literals pour inclure des param√®tres si n√©cessaire

#### Anti-Patterns

- ‚ùå Absence de journalisation en entr√©e : Ne pas logger l'entr√©e de fonction ‚Üí difficult√© de tra√ßabilit√©
- ‚ùå Message g√©n√©rique : `console.log('Loading...')` ‚Üí manque de contexte fonctionnel
- ‚ùå Position incorrecte : Logger apr√®s des op√©rations ‚Üí perte de tra√ßabilit√© initiale

### Pattern 2 : Journalisation en sortie de fonction (succ√®s)

#### Description

Utiliser pour tracer la sortie r√©ussie des fonctions afin de valider le d√©roulement normal des op√©rations.

#### Pattern valid√©

```javascript
async function loadInstructions(config) {
  console.log(`[info] Chargement des instructions depuis config.nuextract.templateTransformationInstructions.instructions`);
  
  try {
    const instructionsArray = config.nuextract.templateTransformationInstructions.instructions;
    const instructions = instructionsArray.join('\n');
    
    // Journalisation en sortie de fonction pour validation du succ√®s
    console.log(`[info] Instructions charg√©es depuis config.nuextract.templateTransformationInstructions.instructions (${instructionsArray.length} instructions)`);
    return instructions;
  } catch (error) {
    console.error(`Erreur lors du chargement des instructions: ${error.message}`);
    throw error;
  }
}
```

#### R√®gles

- **Pr√©fixe `[info]`** : Utiliser `[info]` pour identifier les messages d'information
- **Message contextualis√©** : Indiquer le r√©sultat de l'op√©ration avec contexte utile (ex: nombre d'√©l√©ments trait√©s)
- **Position** : Avant le return, apr√®s le traitement r√©ussi
- **Informations utiles** : Inclure des m√©triques pertinentes si applicables (nombre d'√©l√©ments, dur√©es, etc.)

#### Anti-Patterns

- ‚ùå Message trop verbeux : Inclure trop de d√©tails techniques non pertinents
- ‚ùå Message trop vague : `console.log('Done')` ‚Üí manque de contexte

### Pattern 3 : Journalisation d'erreur avant propagation

#### Description

Utiliser pour logger les erreurs avant leur propagation dans les fonctions d'orchestration, en compl√©ment du pattern de gestion d'erreur (@error-handling-governance Pattern 3).

#### Pattern valid√©

```javascript
async function loadInstructions(config) {
  console.log(`[info] Chargement des instructions depuis config.nuextract.templateTransformationInstructions.instructions`);
  
  try {
    // ... logique m√©tier ...
    return instructions;
  } catch (error) {
    // Message contextualis√© pour identifier facilement la fonction (bonne pratique reconnue)
    console.error(`Erreur lors du chargement des instructions: ${error.message}`);
    throw error; // Propagation simple avec pr√©servation de la stack trace
  }
}
```

#### R√®gles

- **Utiliser `console.error()`** : R√©serv√© aux erreurs (diff√©renci√© de `console.log()` pour l'information)
- **Message contextualis√©** : Le message doit identifier clairement la fonction pour faciliter le d√©bogage
- **Format standardis√©** : `"Erreur lors de {action}: {message d'erreur}"`
- **Avant propagation** : Logger avant `throw error` pour pr√©server la stack trace

#### Anti-Patterns

- ‚ùå Message g√©n√©rique : `console.error('Erreur:', error.message)` ‚Üí manque de contexte fonctionnel
- ‚ùå Propagation sans logging : `catch (error) { throw error; }` ‚Üí perte de tra√ßabilit√©
- ‚ùå Utilisation de `console.log()` pour erreurs : Ne pas diff√©rencier erreurs et informations

### Tableau r√©capitulatif des patterns

| Contexte | Pattern | Exemple | Utilisation |
|:---------|:--------|:--------|:-----------|
| Entr√©e de fonction | `console.log()` avec `[info]` | `console.log('[info] Chargement des instructions...')` | Tra√ßabilit√© ex√©cution |
| Sortie r√©ussie | `console.log()` avec `[info]` | `console.log('[info] Instructions charg√©es (2 instructions)')` | Validation succ√®s |
| Erreur avant propagation | `console.error()` contextualis√© | `console.error('Erreur lors du chargement des instructions: ...')` | Tra√ßabilit√© erreur |

## Validation flexible dans les tests

### Principe de validation flexible

Les tests de logging doivent valider la **pr√©sence** et des **fragments pertinents** des logs plut√¥t que leur contenu exact pour √©viter des refactorings de tests excessifs lors de la maintenance corrective et √©volutive.

### Pattern valid√© pour tests

```typescript
// ‚úÖ Correct : Validation flexible avec toContain()
test('V√©rification pr√©sence console.log() en entr√©e', ({ given, when, then }) => {
  given('une configuration valide', () => {
    config = { nuextract: { templateTransformationInstructions: { instructions: [...] } } };
    jest.spyOn(console, 'log').mockImplementation();
  });
  
  when('on charge les instructions', async () => {
    await loadInstructions(config);
  });
  
  then('un message console.log() est √©mis en entr√©e de fonction', () => {
    expect(console.log).toHaveBeenCalled();
  });
  
  and('le message contient une r√©f√©rence √† "instructions" ou "chargement"', () => {
    const calls = (console.log as jest.Mock).mock.calls;
    const lastCall = calls[calls.length - 1][0];
    expect(lastCall).toContain('instructions'); // Validation flexible avec toContain()
  });
});
```

#### R√®gles pour tests de logging

- **Valider la pr√©sence** : V√©rifier que `console.log()` ou `console.error()` a √©t√© appel√©
- **Validation flexible** : Utiliser `toContain()` pour v√©rifier des fragments pertinents plut√¥t que le contenu exact
- **Fragments pertinents** : V√©rifier la pr√©sence de mots-cl√©s contextuels (nom de fonction, action, etc.)
- **√âviter validations strictes** : Ne pas valider le contenu exact complet du message pour √©viter les refactorings fr√©quents

#### Anti-Patterns pour tests

- ‚ùå Validation stricte du contenu : `expect(logMessage).toBe('[info] Chargement des instructions depuis config.nuextract.templateTransformationInstructions.instructions')` ‚Üí fragile, n√©cessite refactoring √† chaque modification de message
- ‚ùå Validation de formatage exact : Valider les espaces, la ponctuation exacte ‚Üí trop strict
- ‚ùå Validation de cha√Ænes compl√®tes : Tester des messages longs dans leur int√©gralit√© ‚Üí maintenance co√ªteuse

## Validation

- V√©rifier que toutes les fonctions d'orchestration ont un `console.log()` en entr√©e
- V√©rifier que les erreurs sont logg√©es avec `console.error()` avant propagation
- V√©rifier que les messages de log sont contextualis√©s (identifient la fonction)
- V√©rifier que les tests de logging utilisent une validation flexible (`toContain()` plut√¥t que contenu exact)

## √âtat d'impl√©mentation

üöß [En cours de d√©finition - 2025-11-01]

- ‚úÖ R√®gle d√©finie et document√©e
- üöß √Ä impl√©menter : Application progressive sur les fonctions existantes
- üöß √Ä impl√©menter : Tests de validation flexible des logs (dans fichiers s√©par√©s pour exp√©rimentation)
