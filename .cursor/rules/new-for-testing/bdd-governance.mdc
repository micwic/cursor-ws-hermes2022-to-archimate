---
description: "Gouvernance des spécifications détaillées selon les principes Behavior Driven Development"
alwaysApply: true
---

# bdd-governance.mdc : Gouvernance des spécifications détaillées selon les principes Behavior Driven Development

> Créé le : [2025-08-14]  
> Dernière mise à jour : 2025-11-03

## Objectifs de la règle

- Définir la gouvernance des spécifications détaillées selon les principes Behavior Driven Development
- Appliquer le cycle Rouge → Vert → Refactor (TDD/BDD)
- Assurer la cohérence entre les spécifications générales et les spécifications détaillées
- Éviter la redondance et l'incohérence dans l'élaboration des spécifications

## Problèmes résolus/à résoudre

- Confusion entre spécifications générales et spécifications détaillées
- Redondance entre différents niveaux de spécifications
- Manque de cohérence dans l'approche BDD

## Comportement général attendu

- L'IA distingue clairement les spécifications générales des spécifications détaillées
- L'IA applique les principes BDD pour les spécifications détaillées
- L'IA maintient la cohérence avec les spécifications générales

## Contexte d'application et généralités

- Les spécifications détaillées sont issues des processus itératifs des principes Behavior Driven Development
- Elles complètent et détaillent les spécifications générales sans les remplacer
- Elles respectent les principes de ségrégation des domaines

## Principe : Spécifications générales vs spécifications détaillées

### Spécifications générales (fichiers `.mdc` de règles/spécifications)

- **Contenu** : Décisions architecturales et techniques justifiées, patterns validés avec exemples minimalistes, anti-patterns avec solutions recommandées, état d'implémentation
- **Objectif** : Documenter les choix de conception et les principes directeurs
- **Niveau de détail** : Succinct, éviter la redondance avec les fichiers BDD

### Spécifications détaillées (fichiers BDD)

- **`.feature`** : Scénarios Gherkin exhaustifs (Given/When/Then) décrivant tous les comportements attendus
- **`.steps.ts`** : Implémentation complète des steps avec mocking, assertions et logique de test
- **Objectif** : Définir précisément le comportement attendu du code
- **Niveau de détail** : Exhaustif et exécutable

### Règle de non-redondance

- **Les spécifications générales ne doivent PAS dupliquer le contenu des fichiers `.feature` et `.steps.ts`**
- **Les fichiers `.feature` et `.steps.ts` représentent les spécifications détaillées exécutables**
- **Les spécifications générales documentent uniquement les décisions et patterns, pas les scénarios détaillés**

## Règles à appliquer

### Spécifications détaillées BDD

#### Règles obligatoires à appliquer

- **RESPECTER HIÉRARCHIE** : Les spécifications détaillées respectent la hiérarchie des spécifications générales
- **APPLIQUER BDD** : Utiliser les principes Behavior Driven Development pour l'élaboration
- **MAINTENIR COHÉRENCE** : Assurer la cohérence avec les spécifications parentes

#### Comportements interdits/proscrits/à éviter

- **REDONDANCE** : Ne pas dupliquer les spécifications générales
- **INCOHÉRENCE** : Ne pas créer de spécifications contradictoires avec les générales
- **SURSPÉCIFICATION** : Éviter le détail excessif non nécessaire

#### Validation

- Vérifier la cohérence avec les spécifications générales
- Valider l'application des principes BDD
- Contrôler l'absence de redondance

### Cycle Rouge → Vert → Refactor (TDD/BDD)

#### Principe

- **Rouge**: écrire/scénariser un comportement en Gherkin (`.feature`) qui échoue; ajouter le minimum de steps pour reproduire l’échec.
- **Vert**: implémenter le minimum dans les steps pour faire passer le scénario; viser le plus simple qui fonctionne.
- **Refactor**: factoriser les steps, mutualiser dans `__tests__/shared/`, améliorer la lisibilité sans changer le comportement.

#### Critères de validation

- **Exécution**: les scénarios `.feature` ciblés passent via Jest-Cucumber (config partagée).
- **Structure**: features en `__tests__/integration/` ou `__tests__/e2e/`, steps associées, steps partagées en `__tests__/shared/`.
- **Langue**: `# language: fr` en tête des fichiers `.feature`.
- **Traçabilité**: messages de commit alignés: `RED`, `GREEN`, `REFACTOR`.

#### Anti-patterns (à éviter)

- Implémenter avant d’écrire le scénario qui échoue (inversion Rouge→Vert).
- Mélanger tests unitaires et BDD dans les mêmes répertoires.
- Gros refactoring sans scénarios au vert.
- Steps trop couplées au parsing au lieu du comportement.
- Duplication de steps réutilisables non mutualisées.

#### Références

- Voir `@jest-cucumber-governance.mdc` (aspects pratiques Jest-Cucumber : commandes, patterns, structure).
- Voir `@bdd-cucumber-vscode-plugin-governance.mdc` (configuration du plugin VSCode).

### Gestion des messages d'erreur dans les step definitions

#### Règles obligatoires à appliquer pour les messages d'erreur

- **PATTERN REGEX AVEC CAPTURE**: Utiliser des expressions régulières avec groupes de capture pour les validations de messages d'erreur
- **ÉVITER DUPLICATION LITTÉRALE**: Ne pas dupliquer les messages entre fichiers `.feature` et `.steps.ts`
- **MAINTENABILITÉ**: Un changement de message ne doit nécessiter qu'une modification dans le fichier `.feature`

#### Pattern validé

**Step Gherkin** (`.feature`):

```gherkin
Alors une erreur contenant "Invalid JSON response" est générée
```

**Step definition** (`.steps.ts`):

```typescript
then(/^une erreur contenant "(.*)" est générée$/, (expectedMessage) => {
  expect(error).toBeDefined();
  expect(error.message).toContain(expectedMessage);
});
```

#### Justification

- **DRY (Don't Repeat Yourself)**: Un seul step réutilisable pour tous les messages
- **Maintenance simplifiée**: Le message est défini uniquement dans le `.feature`
- **Couplage réduit**: Moins de dépendances entre `.steps.ts` et `.feature`
- **Flexibilité**: Facilite les tests avec messages variables

#### Anti-patterns à éviter

- **Duplication littérale**:

  ```typescript
  // MAUVAIS
  then('une erreur contenant "Invalid JSON" est générée', () => {
    expect(error.message).toContain('Invalid JSON'); // Message dupliqué
  });
  ```

- **Hardcoding dans step definition**:

  ```typescript
  // MAUVAIS
  then(/^une erreur contenant "(.*)" est générée$/, () => {
    expect(error.message).toContain('Invalid JSON'); // Ignore la capture
  });
  ```

#### État d'implémentation

✅ [Appliqué dans tests unitaires - 2025-10-29]

✅ [Harmonisé dans tests intégration mockés - 2025-10-30]

### Structure des tests d'intégration

#### Règles obligatoires à appliquer pour la structure des tests

- **SÉPARATION RÉEL/MOCKÉ** : Organiser les tests selon leur type (réel vs mocké)
- **RÉPERTOIRES SPÉCIALISÉS** : Utiliser des répertoires distincts pour les tests avec appels API réels et les tests avec mocks
- **SUFFIXE MOCKÉ** : Utiliser le suffixe `-mocked` pour les fichiers de tests mockés
- **PAIRES FICHIERS** : Placer les fichiers `.feature` et `.steps.ts` côte à côte dans le même répertoire

#### Patterns validés

**Structure standard pour tests d'intégration :**

```text
__tests__/
  integration/
    with-external-system/          # Tests avec appels API réels
      template-generation.feature
      template-generation.steps.ts
    with-external-system-mocked/   # Tests avec système externe mocké
      template-generation-mocked.feature
      template-generation-mocked.steps.ts
```

#### Portée des mocks (règle)

- **Mocker uniquement les frontières** : Mocker uniquement les composants aux frontières du projet (systèmes externes: APIs, réseau, I/O distants)
- **Ne pas mocker les modules internes** : Ne pas mocker les modules internes entre eux (cela relève de la conception interne et doit être validé par intégration)
- **Exception pour tests d'erreur** : Tests de gestion d'erreurs (error-handling) peuvent mocker de manière ciblée pour valider les chemins d'erreurs et les messages, sans dériver vers des tests d'implémentation

#### Timeouts selon le type de test

**Tests réels (`with-external-system/`) :**

- Mode async : 120s (timeout dans le test : `120000`)
- Mode sync : 45s (timeout dans le test : `45000`)

**Tests mockés (`with-external-system-mocked/`) :**

- Tous les tests : 5s (timeout dans le test : `5000`)

#### Exemples

**Test réel avec timeout async :**

```typescript
test('Génération de template NuExtract avec infer-template-async', ({ given, when, then }) => {
  // ... steps ...
}, 120000); // 120s pour mode async
```

**Test mocké avec timeout court :**

```typescript
test('Erreur HTTP 500 en mode async', ({ given, when, then }) => {
  // ... steps ...
}, 5000); // 5s pour test mocké
```

#### Anti-Patterns à éviter

- **TIMEOUT ABSENT** : Éviter les tests sans timeout explicite → **Solution** : Toujours définir un timeout → **Règle à adopter** : Timeout obligatoire selon le type
- **TIMEOUT INCONFORME** : Éviter les timeouts non conformes à la gouvernance → **Solution** : Respecter async 120s/sync 45s pour réels, < 5s pour mockés → **Règle à adopter** : Timeouts standardisés

#### Bonnes pratiques BDD

- **Fichiers côte à côte** : `.feature` (Gherkin, FR) et `.steps.ts` (jest-cucumber) côte à côte dans le même répertoire
- **Assertions flexibles** : Utiliser `toContain()` pour les fragments de messages plutôt que le contenu exact, conformément à la gouvernance de gestion d'erreurs
- **Hooks d'isolation** : Utiliser `beforeEach`/`afterEach` pour restaurer l'état et éviter les effets de bord entre scénarios

#### Nommage et lisibilité

- **Suffixe mocké** : Les fichiers mockés portent systématiquement le suffixe `-mocked`
- **Noms explicites** : Les répertoires `with-external-system/` et `with-external-system-mocked/` rendent explicite le périmètre (réel vs mocké)

#### Critères de validation pour tests d'intégration

- **Tests réels** : Les scénarios réels doivent pouvoir s'exécuter sans modification des steps en présence d'une configuration valide (clé API, endpoints accessibles)
- **Tests mockés** : Les scénarios mockés doivent passer sans dépendance réseau et couvrir les erreurs clés (HTTP/timeout/JSON/propagation) ainsi que l'orchestration côté client

#### Références pratiques

- Voir `@jest-cucumber-governance.mdc` (workspace) pour les aspects pratiques : commandes d'exécution (`--testPathPatterns`), timeouts, structure détaillée
- Voir `@test-mock-governance.mdc` pour les détails sur l'isolation des mocks

### Distinction validation technique vs validation métier

#### Règles obligatoires à appliquer pour les tests d'intégration réels

- **DISTINCTION CLAIRE** : Distinguer la validation d'exécution (status retourné) de la validation métier (résultat réel dans le réceptacle de données)
- **VALIDATION TECHNIQUE** : Vérifier que l'exécution s'est bien déroulée via le status retourné (ex: `result.updated === true`, `result.id` défini)
- **VALIDATION MÉTIER INDÉPENDANTE** : Pour les opérations modifiant des données, l'intention métier est vérifiée en contrôlant les résultats attendus de manière indépendante à la fonction qui a provoqué le changement, en interrogeant le réceptacle de la donnée (système externe via API, fichier, base de données, etc.)
- **RÉCEPTACLES DE DONNÉES** : La validation métier interroge le réceptacle approprié selon le type d'opération :
  - **Système externe** : Appels API dédiés (ex: `getNuExtractProject()`) pour récupérer l'état réel
  - **Fichiers** : Lecture directe du fichier créé/modifié pour vérifier le contenu
  - **Bases de données** : Requêtes SQL pour vérifier les données enregistrées
  - **Autres réceptacles** : Méthode appropriée pour interroger l'état réel des données

#### Patterns validés

**Validation technique (Then)** :

```typescript
then('le template est mis à jour avec succès', () => {
  // Validation technique : vérifier que l'exécution s'est bien déroulée
  expect(updateResult?.updated).toBe(true);
});
```

**Validation métier (And) - Système externe via API** :

```typescript
and('le projet contient le nouveau template', async () => {
  // Validation métier : récupérer le projet depuis le système externe de manière indépendante
  // et comparer le template (interroger le réceptacle de données)
  const project = await getNuExtractProject(
    config?.nuextract?.baseUrl || 'nuextract.ai',
    config?.nuextract?.port || 443,
    config?.nuextract?.projectsPath || '/api/projects',
    apiKey,
    updateResult.id
  );
  
  expect(project).toBeDefined();
  expect(project.template).toBeDefined();
  expect(project.template.type).toBe('schema');
  expect(project.template.schema).toBeDefined();
  
  // Comparaison profonde du template : structure et contenu
  expect(JSON.stringify(project.template.schema)).toBe(JSON.stringify(newTemplate));
});
```

**Validation métier (And) - Fichier** :

```typescript
and('le template est créé avec succès dans le répertoire de sortie', () => {
  // Validation métier : lire le fichier créé de manière indépendante pour vérifier le contenu
  const templatePath = resolveFromRepoRoot(path.join(templateDirConfig, 'nuextract-template.json'));
  expect(fs.existsSync(templatePath)).toBe(true);
  const templateContent = JSON.parse(fs.readFileSync(templatePath, 'utf8'));
  // Comparaison profonde : le template sauvegardé correspond au template retourné
  expect(template).toEqual(templateContent);
});
```

**Validation métier (And) - Base de données** :

```typescript
and('les données sont enregistrées dans la base de données', async () => {
  // Validation métier : interroger la base de données de manière indépendante pour vérifier les données
  const dbResult = await db.query('SELECT * FROM projects WHERE id = ?', [projectResult.id]);
  expect(dbResult).toBeDefined();
  expect(dbResult.template).toBeDefined();
  // Comparaison profonde des données enregistrées
  expect(JSON.stringify(dbResult.template)).toBe(JSON.stringify(expectedTemplate));
});
```

#### Justification

- **Validation technique** : Confirme que l'exécution s'est déroulée sans erreur (infrastructure OK)
- **Validation métier indépendante** : Confirme que le résultat métier attendu a été effectivement atteint dans le réceptacle de données (intention métier respectée), indépendamment de la fonction qui a provoqué le changement
- **Robustesse** : La validation métier garantit que le changement a été appliqué réellement dans le réceptacle de données (système externe, fichier, base de données, etc.), pas seulement que la fonction a retourné un status de succès
- **Indépendance** : En interrogeant directement le réceptacle de données, on évite de dépendre de l'implémentation de la fonction qui a effectué la modification

#### Anti-Patterns à éviter

- **Validation uniquement technique** : Éviter de valider uniquement le status retourné pour les opérations modifiant des données → **Solution** : Ajouter validation métier en interrogeant le réceptacle de données approprié (API, fichier, base de données, etc.) → **Règle à adopter** : Distinction claire technique vs métier
- **Dépendance à la fonction** : Éviter de valider le résultat métier en se fiant uniquement à la valeur retournée par la fonction qui a provoqué le changement → **Solution** : Interroger directement le réceptacle de données pour vérifier l'état réel → **Règle à adopter** : Validation métier indépendante de l'implémentation
- **Redondance dans validation métier** : Éviter de re-valider ce qui est déjà validé par la validation technique → **Solution** : Validation métier se concentre sur le résultat réel dans le réceptacle, pas sur le status d'exécution → **Règle à adopter** : Séparation des responsabilités

#### État d'implémentation

✅ [Appliqué dans tests d'intégration - 2025-11-03]

### Principe de non-redondance dans les assertions

#### Règles obligatoires à appliquer

- **ÉVITER REDONDANCE GIVEN/THEN** : Ne pas valider dans `Then` ce qui est déjà validé dans `Given`
- **DÉLÉGUER AUX FONCTIONS** : Si une fonction interne valide déjà quelque chose, ne pas re-valider dans les tests d'intégration
- **VÉRIFICATIONS MINIMALES** : Limiter les vérifications dans `Given` et `And` aux vérifications minimales nécessaires pour le contexte du test

#### Patterns validés

**Vérification minimale dans Given** :

```typescript
given('des paramètres de configuration NuExtract pour la génération du template', async () => {
  config = await loadGlobalConfig();
  // Forcer le mode async pour ce scénario réel
  config.nuextract.templateMode = 'async';
  // Vérification minimale : les validations détaillées sont effectuées par loadGlobalConfig()
  expect(config?.nuextract?.templateMode).toBe('async');
});
```

**Éviter redondance avec fonctions internes** :

```typescript
and('des instructions de transformation depuis config', () => {
  // Validation redondante supprimée : loadInstructions() valide déjà la présence et le type array
  // Si les instructions sont absentes ou invalides, loadInstructions() lèvera une erreur
});
```

#### Justification

- **DRY (Don't Repeat Yourself)** : Éviter de dupliquer les validations déjà effectuées par les fonctions internes
- **Maintenance simplifiée** : Un changement dans la validation interne ne nécessite pas de modification des tests
- **Focus sur l'intention** : Les tests d'intégration se concentrent sur l'intention métier, pas sur les détails de validation déjà gérés par les fonctions internes

#### Anti-Patterns à éviter

- **Redondance Given/Then** : Éviter de valider `expect(template).toBeDefined()` dans `Then` si `template` a déjà été validé dans `Given` → **Solution** : Supprimer validation redondante → **Règle à adopter** : Chaque assertion a un objectif distinct
- **Re-validation interne** : Éviter de re-valider ce qui est déjà validé par `loadGlobalConfig()`, `loadApiKey()`, `loadInstructions()`, etc. → **Solution** : Faire confiance aux fonctions internes et leurs validations → **Règle à adopter** : Vérifications minimales dans tests d'intégration

#### État d'implémentation

✅ [Appliqué dans tests d'intégration - 2025-11-03]

### Profondeur des assertions Then

#### Règles obligatoires à appliquer

- **INTENTION MÉTIER** : Les assertions `Then` doivent valider l'intention métier, pas seulement la présence de variables
- **RÉSULTAT RÉEL** : Pour les opérations modifiant des données, valider le résultat réel obtenu depuis le réceptacle de données (système externe, fichier, base de données, etc.)
- **VALIDATION INDÉPENDANTE** : Interroger directement le réceptacle de données de manière indépendante à la fonction qui a provoqué le changement
- **PROFONDEUR APPROPRIÉE** : La profondeur des assertions doit être proportionnelle à la complexité de l'opération testée

#### Patterns validés

**Assertion Then profonde (validation métier)** :

```typescript
then('le projet contient le template fourni', async () => {
  // Validation métier : récupérer le projet depuis le système externe et vérifier le template
  const project = await getNuExtractProject(
    config?.nuextract?.baseUrl || 'nuextract.ai',
    config?.nuextract?.port || 443,
    config?.nuextract?.projectsPath || '/api/projects',
    apiKey,
    projectResult.id
  );
  
  expect(project).toBeDefined();
  expect(project.template).toBeDefined();
  expect(project.template.type).toBe('schema');
  expect(project.template.schema).toBeDefined();
  
  // Comparaison profonde du template : structure et contenu
  expect(JSON.stringify(project.template.schema)).toBe(JSON.stringify(template));
});
```

#### Justification

- **Intention métier** : Les tests BDD valident l'intention métier, pas seulement l'exécution technique
- **Robustesse** : La validation du résultat réel garantit que l'opération a effectivement atteint son objectif métier
- **Cohérence** : Les assertions profondes assurent la cohérence entre l'intention métier et le résultat effectif

#### Anti-Patterns à éviter

- **Assertion superficielle** : Éviter `expect(template).toBeDefined()` dans `Then` si `template` est déjà validé dans `Given` → **Solution** : Supprimer assertion redondante ou la remplacer par validation métier → **Règle à adopter** : Chaque assertion ajoute de la valeur
- **Validation uniquement technique** : Éviter de valider uniquement le status retourné sans vérifier le résultat réel dans le réceptacle → **Solution** : Ajouter validation métier en interrogeant le réceptacle approprié (API, fichier, base de données, etc.) → **Règle à adopter** : Profondeur appropriée selon le type d'opération
- **Dépendance à l'implémentation** : Éviter de valider le résultat en se fiant uniquement à la valeur retournée par la fonction → **Solution** : Interroger directement le réceptacle de données pour obtenir l'état réel → **Règle à adopter** : Validation métier indépendante

#### État d'implémentation

✅ [Appliqué dans tests d'intégration - 2025-11-03]

### Évolution à prévoir

- Extension des principes BDD selon l'évolution du projet
- Adaptation des spécifications détaillées aux nouveaux besoins
