---
description: "Gouvernance des spécifications détaillées selon les principes Behavior Driven Development"
alwaysApply: true
---

# bdd-governance.mdc : Gouvernance des spécifications détaillées selon les principes Behavior Driven Development

> Créé le : [2025-08-14]  
> Dernière mise à jour : 2025-11-15

## Objectifs de la règle

- Définir la gouvernance des spécifications détaillées selon les principes Behavior Driven Development
- Appliquer le cycle Rouge → Vert → Refactor (TDD/BDD)
- Assurer la cohérence entre les spécifications générales et les spécifications détaillées
- Éviter la redondance et l'incohérence dans l'élaboration des spécifications

## Problèmes résolus/à résoudre

- Confusion entre spécifications générales et spécifications détaillées
- Redondance entre différents niveaux de spécifications
- Manque de cohérence dans l'approche BDD

## Comportement général attendu

- L'IA distingue clairement les spécifications générales des spécifications détaillées
- L'IA applique les principes BDD pour les spécifications détaillées
- L'IA maintient la cohérence avec les spécifications générales

## Contexte d'application et généralités

- Les spécifications détaillées sont issues des processus itératifs des principes Behavior Driven Development
- Elles complètent et détaillent les spécifications générales sans les remplacer
- Elles respectent les principes de ségrégation des domaines

## Principe : Spécifications générales vs spécifications détaillées

### Spécifications générales (fichiers `.mdc` de règles/spécifications)

- **Contenu** : Décisions architecturales et techniques justifiées, patterns validés avec exemples minimalistes, anti-patterns avec solutions recommandées, état d'implémentation
- **Objectif** : Documenter les exigences à supporter (Règles de gestion, principes et contraintes à respecter), les choix de conception et les principes directeurs qui en découlent dans le contexte
- **Niveau de détail** : Suffisant pour exprimer le besoin à couvrir et le cadre à respecter, éviter la redondance avec les fichiers BDD

### Spécifications détaillées (fichiers BDD)

- **`.feature`** : Scénarios Gherkin exhaustifs (Given/When/Then) décrivant tous les comportements attendus
- **`.steps.ts`** : Implémentation complète des steps avec mocking, assertions et logique de test
- **Objectif** : Définir précisément le comportement attendu du code
- **Niveau de détail** : Exhaustif et exécutable

### Règle de non-redondance

- **Les spécifications générales ne doivent PAS dupliquer le contenu des fichiers `.feature` et `.steps.ts`**
- **Les fichiers `.feature` et `.steps.ts` représentent les spécifications détaillées exécutables**
- **Les spécifications générales documentent uniquement les décisions et patterns, pas les scénarios détaillés**

## Règles à appliquer

### Spécifications détaillées BDD

#### Règles obligatoires à appliquer

- **RESPECTER HIÉRARCHIE** : Les spécifications détaillées respectent la hiérarchie des spécifications générales
- **APPLIQUER BDD** : Utiliser les principes Behavior Driven Development pour l'élaboration
- **MAINTENIR COHÉRENCE** : Assurer la cohérence avec les spécifications parentes

#### Comportements interdits/proscrits/à éviter

- **REDONDANCE** : Ne pas dupliquer les spécifications générales
- **INCOHÉRENCE** : Ne pas créer de spécifications contradictoires avec les spécifications générales
- **SURSPÉCIFICATION** : Éviter le détail excessif non nécessaire

#### Validation

- Vérifier la cohérence avec les spécifications générales
- Valider l'application des principes BDD
- Contrôler l'absence de redondance

### Cycle Rouge → Vert → Refactor (TDD/BDD)

#### Principe pour le cycle BDD

- **Rouge**: écrire/scénariser un comportement attendu en Gherkin (`.feature`) qui vérifie le résultat attendu et qui échouera nécessairement aux premières tentatives d'exécution; ajouter le minimum de steps (`.steps.ts`) jusqu'à reproduire l’échec à l'exécution du test mais à permettre l'exécution du test.
- **Vert**: implémenter le minimum dans le code et les steps pour faire passer le scénario avec le résultat attendu; viser le plus simple qui fonctionne.
- **Refactor**: améliorer et étendre le code, factoriser les steps, mutualiser dans `__tests__/shared/`, améliorer la lisibilité sans changer le résultat.

#### Critères de validation

- **Exécution**: les scénarios `.feature` ciblés passent via Jest-Cucumber (config partagée).
- **Structure**: features en `__tests__/integration/` ou `__tests__/e2e/`, steps associées, steps partagées en `__tests__/shared/`.
- **Langue**: `# language: fr` en tête des fichiers `.feature`.

#### Anti-patterns (à éviter)

- Implémenter avant d’écrire le scénario qui échoue (inversion Rouge→Vert).
- Mélanger tests unitaires et BDD dans les mêmes répertoires.
- Gros refactoring sans scénarios au vert.
- Steps trop couplées au parsing au lieu du comportement.
- Duplication de steps réutilisables non mutualisées.

#### Références

- Voir `@jest-cucumber-governance.mdc` (aspects pratiques Jest-Cucumber : commandes, patterns, structure).
- Voir `@bdd-cucumber-vscode-plugin-governance.mdc` (configuration du plugin VSCode).

### Gestion des messages d'erreur dans les step definitions

#### Principes pour les messages d'erreur

- L'implémentation de la gestion attendue des erreurs dans le code est testée dans des tests unitaires dédiés
- Le nom des fichiers de tests reprend le nom du fichier qui contient le code suivi de `-error-handling`
  - Exemple : `nuextract-client.js` → `nuextract-client-error-handling.feature` et `.steps.ts`
- Les fichiers de tests représentent une source d'information pour l'élaboration du manuel d'erreur et le contrôle de qualité

#### Règles obligatoires à appliquer pour les messages d'erreur

- **PATTERN REGEX AVEC CAPTURE**: Utiliser des expressions régulières avec groupes de capture pour les validations de messages d'erreur
- **ÉVITER DUPLICATION LITTÉRALE**: Ne pas dupliquer les messages entre fichiers `.feature` et `.steps.ts`
- **MAINTENABILITÉ**: Un changement de message ne doit nécessiter qu'une modification dans le fichier `.feature`

#### Pattern validé

**Step Gherkin** (`.feature`):

```gherkin
Alors une erreur contenant "Invalid JSON response" est générée
```

**Step definition** (`.steps.ts`):

```typescript
then(/^une erreur contenant "(.*)" est générée$/, (expectedMessage) => {
  expect(error).toBeDefined();
  expect(error.message).toContain(expectedMessage);
});
```

#### Justification

- **DRY (Don't Repeat Yourself)**: Un seul step réutilisable pour tous les messages
- **Maintenance simplifiée**: Le message est défini uniquement dans le `.feature`
- **Couplage réduit**: Moins de dépendances entre `.steps.ts` et `.feature`
- **Flexibilité**: Facilite les tests avec messages variables

#### Anti-patterns à éviter

- **Duplication littérale**:

  ```typescript
  // MAUVAIS
  then('une erreur contenant "Invalid JSON" est générée', () => {
    expect(error.message).toContain('Invalid JSON'); // Message dupliqué
  });
  ```

- **Hardcoding dans step definition**:

  ```typescript
  // MAUVAIS
  then(/^une erreur contenant "(.*)" est générée$/, () => {
    expect(error.message).toContain('Invalid JSON'); // Ignore la capture
  });
  ```

#### État d'implémentation

✅ [Appliqué dans tests unitaires - 2025-10-29]

✅ [Harmonisé dans tests intégration mockés - 2025-10-30]

### Organisation des tests BDD

#### Principes généraux d'organisation

- **SÉPARATION PAR PORTÉE** : Distinguer tests unitaires (unité isolée) et tests d'intégration (interaction entre composants/systèmes)
- **COHÉRENCE D'ORGANISATION** : Maintenir une structure claire et prévisible pour faciliter la navigation
- **PAIRES FICHIERS** : Placer les fichiers `.feature` (Gherkin) et `.steps.ts` (implémentation) côte à côte dans le même répertoire
- **NOMMAGE EXPLICITE** : Utiliser des noms de fichiers et répertoires qui décrivent clairement la portée et l'objectif des tests

#### Tests unitaires vs Tests d'intégration

**Tests unitaires (`__tests__/unit/`)** :

- **Portée** : Testent une **fonction ISOLÉE** (fonction, classe, module)
- **Objectif** : Valider le comportement d'une unité indépendamment du reste du système
- **Mocks** : **TOUTES** les dépendances sont mockées (internes + externes)
- **Rapidité** : Généralement rapides (< 5-10s), pas de dépendances externes
- **Exemple** : Test de `orchestrateWorkflow()` en mockant `fetchData()`, `transformData()`, `saveResult()`, etc.
- **Répertoire** : `__tests__/unit/`

**Tests d'intégration mockés (`__tests__/integration/with-external-system-mocked/`)** :

- **Portée** : Testent l'**intégration des composants INTERNES** du système
- **Objectif** : Valider que les composants internes fonctionnent correctement ensemble
- **Mocks** : Uniquement la **frontière externe** (API externes, fetch réseau, base de données externes)
- **Pas de mock** : Orchestration interne, fonctions métier, recomposition, normalisation
- **Critère clé** : Mock à la **frontière système/externe uniquement**
- **Rapidité** : Rapides (5-15s), pas d'appels réseau réels
- **Exemple** : Test du workflow complet en mockant uniquement les appels API externes et les fetch réseau
- **Répertoire** : `__tests__/integration/with-external-system-mocked/`

**Tests d'intégration réels (`__tests__/integration/with-external-system/`)** :

- **Portée** : Testent l'**intégration complète** avec systèmes externes réels
- **Objectif** : Valider le fonctionnement end-to-end avec les vraies API et ressources
- **Mocks** : **AUCUN**
- **Durée** : Plus lents (15-120s selon complexité), dépendent du réseau et des systèmes externes
- **Exemple** : Workflow complet avec appels API réels et accès aux ressources externes réelles
- **Répertoire** : `__tests__/integration/with-external-system/`

**Note importante** : La présence ou l'absence de mocks ne définit PAS le type de test. Ce qui distingue les niveaux est :
- **Unit** : Portée = fonction isolée
- **Integration mocké** : Portée = workflow interne complet, mock = frontière externe uniquement
- **Integration réel** : Portée = end-to-end complet

#### Usage des mocks selon le niveau de test

**Règle générale** : Le mock doit correspondre au niveau de test et à la frontière testée.

**Tests unitaires** :
- Mock **toutes** les dépendances (internes + externes)
- Objectif : isoler complètement la fonction testée
- Exemple : `jest.mock('./data-transformer.js')`, `jest.mock('./api-client.js')`

**Tests d'intégration mockés** :
- Mock **uniquement** la frontière externe (API, réseau, filesystem externe, base de données externes)
- **Ne pas mocker** les composants internes du système
- Objectif : tester le workflow interne réel avec systèmes externes simulés
- Exemple : Mock `https.request()` pour API externe, mock `fetch()` pour ressources HTTP distantes
- **Critère décisif** : La frontière système/externe

**Tests d'intégration réels** :
- **Aucun mock**
- Objectif : validation end-to-end réelle
- Contraintes : Nécessite connectivité réseau, quotas API, coûts potentiels

**Critères de choix** : Utiliser des mocks selon les contraintes du projet (coût API, quotas, disponibilité réseau, déterminisme des tests, vitesse d'exécution) et **le niveau de test** (unit vs integration).

#### Timeouts

- **TIMEOUT OBLIGATOIRE** : Tous les tests doivent définir un timeout explicite pour éviter les blocages
- **ADAPTATION AU CONTEXTE** : Le timeout doit être adapté à la nature du test (rapide pour unitaires/mockés, plus long pour intégration avec systèmes réels)
- **COHÉRENCE** : Maintenir des timeouts cohérents pour des tests de même nature dans le projet

#### Bonnes pratiques BDD générales

- **Fichiers côte à côte** : `.feature` (Gherkin) et `.steps.ts` (implémentation) dans le même répertoire
- **Assertions flexibles** : Préférer `toContain()` pour fragments de messages plutôt que contenu exact complet
- **Hooks d'isolation** : Utiliser `beforeEach`/`afterEach` pour restaurer l'état et éviter effets de bord entre scénarios
- **Nommage descriptif** : Noms de scénarios clairs décrivant le comportement testé (pas l'implémentation)
- **Steps réutilisables** : Factoriser les steps communs pour éviter duplication

#### Anti-Patterns généraux à éviter

- **TIMEOUT ABSENT** : Ne jamais omettre le timeout → Risque de tests bloqués indéfiniment
- **NOMMAGE TECHNIQUE** : Éviter noms de tests basés sur l'implémentation → Privilégier comportement métier
- **DUPLICATION STEPS** : Éviter duplication de steps identiques → Factoriser dans steps réutilisables
- **ASSERTIONS FRAGILES** : Éviter assertions trop strictes (contenu exact complet) → Valider fragments clés

#### Références pour organisation BDD

- Voir spécifications du projet pour détails d'organisation spécifiques (structure répertoires, nommage, timeouts précis)
- Voir `@jest-cucumber-governance.mdc` pour aspects pratiques Jest-Cucumber
- Voir `@test-mock-governance.mdc` pour isolation des mocks
- Voir `@code-modularity-governance.mdc` pour principes SOLID

### Profondeur des assertions BDD

#### Règles obligatoires pour profondeur des assertions

- **VALIDATION TECHNIQUE** : Vérifier que l'opération s'est exécutée sans erreur (status, code retour, absence d'exception)
- **VALIDATION MÉTIER** : Pour les opérations avec effets de bord, valider le résultat réel attendu
- **INDÉPENDANCE VALIDATION** : Pour valider des effets de bord, interroger directement le réceptacle de données (API, fichier, base de données) plutôt que se fier uniquement au retour de la fonction
- **PROFONDEUR APPROPRIÉE** : Adapter la profondeur des assertions à la complexité et criticité de l'opération

#### Principes généraux

**Validation technique** :

- Confirme que l'exécution s'est déroulée sans erreur
- Vérifie les codes retour, status, présence de résultats attendus
- Rapide et déterministe

**Validation métier** :

- Confirme que l'intention métier a été atteinte
- Pour opérations avec effets de bord : interroge le réceptacle de données
- Peut nécessiter des appels supplémentaires (lecture API, fichier, base de données)

#### Pattern général : Validation en deux temps

```gherkin
Alors l'opération s'exécute avec succès          # Validation technique
Et le résultat attendu est présent dans le système   # Validation métier
```

#### Anti-Patterns pour profondeur des assertions

- **Validation superficielle** : Éviter de valider uniquement `expect(result).toBeDefined()` → **Solution** : Valider le contenu réel pertinent
- **Validation uniquement technique** : Pour opérations avec effets de bord, ne pas se fier uniquement au status retourné → **Solution** : Interroger le réceptacle de données
- **Redondance excessive** : Éviter de re-valider ce qui est déjà validé ailleurs → **Solution** : Chaque assertion a un objectif distinct

#### Références pour profondeur des assertions

- Voir spécifications du projet pour exemples concrets de validation métier

### Principe de non-redondance dans les assertions

#### Règles obligatoires pour non-redondance

- **DRY (Don't Repeat Yourself)** : Éviter de dupliquer les validations entre différentes parties du test
- **ÉVITER REDONDANCE GIVEN/THEN** : Ne pas valider dans `Then` ce qui est déjà validé dans `Given`
- **DÉLÉGUER AUX FONCTIONS** : Faire confiance aux validations déjà effectuées par les fonctions du système sous test
- **VÉRIFICATIONS MINIMALES** : Limiter les vérifications dans `Given` et `And` au minimum nécessaire pour établir le contexte

#### Justification de non-redondance

- **Maintenance simplifiée** : Un changement dans une validation interne ne nécessite pas de modification multiple des tests
- **Focus sur l'intention** : Les tests se concentrent sur l'intention métier, pas sur la répétition de validations techniques
- **Lisibilité** : Tests plus concis et plus faciles à comprendre

#### Anti-Patterns pour non-redondance

- **Redondance Given/Then** : Valider la même chose dans `Given` et `Then` → **Solution** : Chaque assertion a un objectif distinct
- **Re-validation de pré-conditions** : Re-valider ce que les fonctions d'initialisation ont déjà validé → **Solution** : Faire confiance aux fonctions internes

### Tests des fonctions nested

#### Principe pour les tests de fonctions nested

- **Pas de tests directs** : Les fonctions nested ne doivent pas avoir de tests unitaires directs
- **Tests via parent** : Le comportement des fonctions nested est testé via leur fonction parent
- **Pas d'exports _testOnly_** : Les fonctions nested n'ont jamais d'export (ni normal ni _testOnly_)

#### Justification pour tests via parent

- **Encapsulation préservée** : Les fonctions nested sont des détails d'implémentation privés
- **Tests comportement complet** : Tester le parent valide automatiquement le comportement des helpers nested
- **Maintenance simplifiée** : Refactoring des nested sans impact sur les tests
- **Surface de test réduite** : Moins de tests à maintenir sans perte de couverture

#### Patterns validés pour tests de fonctions nested

##### Exemple 1 : Tests de fonctionnement (cas nominal)

**Code source** :

```javascript
async function processData(data, config) {
  // Fonction helper nested pour transformer les données
  function transformData(data) {
    return {
      id: data.id,
      name: data.name.toUpperCase(),
      timestamp: new Date().toISOString()
    };
  }
  
  // Fonction helper nested pour enrichir les données
  function enrichData(transformed, config) {
    return {
      ...transformed,
      processed: true,
      version: config.version || '1.0'
    };
  }
  
  // Utilisation des helpers nested
  const transformed = transformData(data);
  const enriched = enrichData(transformed, config);
  
  return enriched;
}
```

**Test BDD via parent** (`processData-success.feature`) :

```gherkin
Fonctionnalité: Traitement de données avec helpers nested

Scénario: Transformation et enrichissement de données valides
  Etant donné des données avec id "test-123" et name "alice"
  Et une configuration avec version "2.0"
  Quand on appelle processData avec ces données
  Alors le résultat contient l'id "test-123"
  Et le name est en majuscules "ALICE"
  Et processed est true
  Et version est "2.0"
  Et timestamp est défini
```

**Step definitions** (`processData-success.steps.ts`) :

```typescript
test('Transformation et enrichissement de données valides', ({ given, when, then, and }) => {
  let data, config, result;
  
  given(/^des données avec id "(.*)" et name "(.*)"$/, (id, name) => {
    data = { id, name };
  });
  
  and(/^une configuration avec version "(.*)"$/, (version) => {
    config = { version };
  });
  
  when('on appelle processData avec ces données', async () => {
    result = await processData(data, config);
  });
  
  then(/^le résultat contient l'id "(.*)"$/, (expectedId) => {
    expect(result.id).toBe(expectedId);
  });
  
  and(/^le name est en majuscules "(.*)"$/, (expectedName) => {
    expect(result.name).toBe(expectedName);
  });
  
  and('processed est true', () => {
    expect(result.processed).toBe(true);
  });
  
  and(/^version est "(.*)"$/, (expectedVersion) => {
    expect(result.version).toBe(expectedVersion);
  });
  
  and('timestamp est défini', () => {
    expect(result.timestamp).toBeDefined();
  });
});
```

**Observation** : Les tests du parent `processData()` valident automatiquement le comportement des helpers nested `transformData()` et `enrichData()` sans avoir besoin de tests directs.

##### Exemple 2 : Tests de gestion d'erreur (fichier séparé)

**Code source** (avec validation nested) :

```javascript
async function processData(data, config) {
  // Fonction helper nested pour valider les données
  function validateData(data) {
    if (!data || typeof data !== 'object') {
      throw new Error('Invalid data: must be a non-null object. Script stopped.');
    }
    if (!data.id) {
      throw new Error('Invalid data: id is required. Script stopped.');
    }
    if (!data.name || typeof data.name !== 'string') {
      throw new Error('Invalid data: name is required and must be a string. Script stopped.');
    }
    return true;
  }
  
  // Validation via helper nested
  validateData(data);
  
  // Logique métier (transformData, enrichData...)
  return processedResult;
}
```

**Test BDD via parent** (`processData-error-handling.feature`) :

```gherkin
Fonctionnalité: Gestion des erreurs processData

Scénario: Erreur données null
  Etant donné des données null
  Quand on tente d'appeler processData
  Alors une erreur contenant "Invalid data: must be a non-null object" est générée

Scénario: Erreur id manquant
  Etant donné des données sans id
  Quand on tente d'appeler processData
  Alors une erreur contenant "Invalid data: id is required" est générée

Scénario: Erreur name invalide
  Etant donné des données avec name de type number
  Quand on tente d'appeler processData
  Alors une erreur contenant "name is required and must be a string" est générée
```

**Step definitions** (`processData-error-handling.steps.ts`) :

```typescript
test('Erreur données null', ({ given, when, then }) => {
  let error;
  
  given('des données null', () => {
    // Pas de setup nécessaire
  });
  
  when('on tente d\'appeler processData', async () => {
    try {
      await processData(null, {});
    } catch (e) {
      error = e;
    }
  });
  
  then(/^une erreur contenant "(.*)" est générée$/, (expectedMessage) => {
    expect(error).toBeDefined();
    expect(error.message).toContain(expectedMessage);
  });
});

test('Erreur id manquant', ({ given, when, then }) => {
  let error;
  
  given('des données sans id', () => {
    // Pas de setup nécessaire
  });
  
  when('on tente d\'appeler processData', async () => {
    try {
      await processData({ name: 'test' }, {});
    } catch (e) {
      error = e;
    }
  });
  
  then(/^une erreur contenant "(.*)" est générée$/, (expectedMessage) => {
    expect(error).toBeDefined();
    expect(error.message).toContain(expectedMessage);
  });
});
```

**Observation** : Les tests de gestion d'erreur du parent `processData()` valident automatiquement le comportement du helper nested `validateData()` sans avoir besoin de tests directs. Les tests d'erreur sont dans un fichier séparé `-error-handling` selon la convention établie.

#### Anti-Patterns pour tests de fonctions nested

- **Tests directs du nested** : Éviter de créer des tests unitaires pour les fonctions nested → **Solution** : Tester via parent → **Règle** : Pas d'export _testOnly_ pour nested
- **Duplication de tests** : Éviter de tester les mêmes cas via parent ET via nested → **Solution** : Uniquement via parent → **Règle** : Supprimer tests obsolètes après conversion en nested
- **Export _testOnly_ du nested** : Éviter d'exposer les nested pour tests → **Solution** : Encapsulation stricte → **Règle** : Nested = détail d'implémentation privé

#### Références pour tests de fonctions nested

- Voir `@code-modularity-governance.mdc` pour critères de conversion en nested
- Voir spécifications du projet pour exemples concrets d'implémentation

### Évolution à prévoir

- Extension des principes BDD selon l'évolution du projet
- Adaptation des spécifications détaillées aux nouveaux besoins
